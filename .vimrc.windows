
source ~/.llvm.vimrc       " this is a must!

set guifont=Consolas:h16:cANSI:qDRAFT

nmap ,6 :set invpaste paste?<CR>
set pastetoggle=,6
set showmode
set fencs=ucs-bom,utf-8,cp949,euc-kr

set bg=dark
set ruler
set number
set modifiable
set hlsearch
set mouse=c
set incsearch
set ignorecase
set smartcase
set printoptions=portrait:y,wrap:y,duplex:off

let g:debuggerMapDefaultKeys = 1

filetype off                   " required!

set rtp+=~/.vim/bundle/Vundle.vim

"call vundle#begin('~/.vim/bundle')
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'
Plugin 'scrooloose/nerdtree'
Plugin 'taglist.vim'
Plugin 'bufexplorer.zip'

call vundle#end()

"set rtp+=~/.vim/bundle/vundle/
"call vundle#rc()
"Bundle 'gmarik/vundle'
"Bundle 'snipMate'
"Bundle 'L9'
"Bundle 'FuzzyFinder'
"Bundle 'The-NERD-tree'
"Bundle 'taglist.vim'
"Bundle 'bufexplorer.zip'
"Bundle 'DirDiff.vim'
"Bundle 'rmartinho/vim-cpp11'
"Bundle 'XDebug-DBGp-client-for-PHP'

filetype plugin indent on     " required!

let NERDTreeWinPos='right'

nmap ,2 v]}zf
nmap ,3 zo

nmap ,4 :Tlist<CR><C-W><C-W>
nmap ,5 :NERDTreeToggle<CR>

let g:hitog = 0
function! Ht() "Highlight toggle
  if (g:hitog == 0)
    let g:hitog = 1
    execute ("highlight LongLine ctermbg=8")
  else
    let g:hitog = 0
    execute ("highlight LongLine ctermbg=DarkYellow guibg=DarkYellow")
  endif
endfunction
nmap ,7 :call Ht()<cr>

nmap ,9 :BufExplorer<cr>

map <PageUp> <C-U><C-U>
map <PageDown> <C-D><C-D>

nmap <C-H> <C-W>h
nmap <C-J> <C-W>j
nmap <C-K> <C-W>k
nmap <C-L> <C-W>l

nmap <S-H> <C-W><<C-W><<C-W><<C-W><
nmap <S-J> <C-W>-<C-W>-<C-W>-<C-W>-
nmap <S-K> <C-W>+<C-W>+<C-W>+<C-W>+
nmap <S-L> <C-W>><C-W>><C-W>><C-W>>

map ,x :bn!<CR>	  " Switch to Next File Buffer
map ,z :bp!<CR>	  " Switch to Previous File Buffer
map ,w :bw<CR>	  " Close Current File Buffer

if version >= 500

  func! Sts()
    let st = expand("<cword>")
    exe "sts ".st
  endfunc
  nmap ,st :call Sts()<cr>

  func! Tj()
    let st = expand("<cword>")
    exe "tj ".st
  endfunc
  nmap ,tj :call Tj()<cr>

  func! Tn()
    exe "tn"
  endfunc
  nmap ,tn :call Tn()<cr>

  func! Tp()
    exe "tp"
  endfunc
  nmap ,tp :call Tp()<cr>

  func! Tr()
    exe "tr"
  endfunc
  nmap ,tr :call Tr()<cr>

  func! Tl()
    exe "tl"
  endfunc
  nmap ,tl :call Tl()<cr>

endif


set csto=0
set cst

if version >= 500

  func! Csw()
    exe "cs show"
  endfunc
  nmap ,csw :call Csw()<cr>

  func! Csc()
    let csc = expand("<cword>")
    new
    exe "cs find c ".csc
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,csc :call Csc()<cr>

  func! Csd()
    let csd = expand("<cword>")
    new
    exe "cs find d ".csd
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,csd :call Csd()<cr>

  func! Cse()
    let cse = expand("<cword>")
    new
    exe "cs find e ".cse
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,cse :call Cse()<cr>

  func! Csf()
    let csf = expand("<cword>")
    new
    exe "cs find f ".csf
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,csf :call Csf()<cr>

  func! Csg()
    let csg = expand("<cword>")
    new
    exe "cs find g ".csg
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,csg :call Csg()<cr>

  func! Csi()
    let csi = expand("<cword>")
    new
    exe "cs find i ".csi
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,csi :call Csi()<cr>

  func! Css()
    let css = expand("<cword>")
    new
    exe "cs find s ".css
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,css :call Css()<cr>

  func! Cst()
    let cst = expand("<cword>")
    new
    exe "cs find t ".cst
    if getline(1) == " "
      exe "q!"
    endif
  endfunc
  nmap ,cst :call Cst()<cr>

endif


if filereadable("cscope.out")
  set nocsverb
  cs add cscope.out
  set csverb
endif


if version >= 500

  "============ man page setting =============
  func! Man()
    let sm = expand("<cword>")
    exe "!man -S 2:3:4:5:6:7:8:9:tcl:n:l:p:o ".sm
  endfunc
  nmap ,ma :call Man()<cr><cr>

  "============ make setting =============
  let startdir = getcwd()
  func! Make()
    exe "!cd ".startdir
    exe "make"
  endfunc
  nmap ,mk :call Make()<cr><cr>

  "============ clean make setting =============
  func! CleanMake()
    exe "!cd ".startdir
    exe "make clean"
    exe "make"
  endfunc
  nmap ,cmk :call CleanMake()<cr><cr>

  "============ hexViewer setting =============
  let g:hexViewer = 0
  func! Hv()
    if (g:hexViewer == 0)
      let g:hexViewer = 1
      exe "%!xxd"
    else
      let g:hexViewer = 0
      exe "%!xxd -r"
    endif
  endfunc
  nmap ,h :call Hv()<cr>

  "============ file buffer CleanClose =============
  func! CleanClose(tosave)
    if (a:tosave == 1)
      w!
    endif
    let todelbufNr = bufnr("%")
    let newbufNr = bufnr("#")
    if ((newbufNr != -1) && (newbufNr != todelbufNr) && buflisted(newbufNr))
      exe "b".newbufNr
    else
      bnext
    endif

    if (bufnr("%") == todelbufNr)
      new
    endif
    exe "bd".todelbufNr
  endfunc

  nmap ,cf :call CleanClose(0)<cr>

  "============ open CWD =============
  nmap ,od :e ./<cr>

endif


